---
title: "Network Analysis for RADx-UP Scientific Collaboration (or coauthorship)"
author: "Josephine McKelvy"
date: "2023-01-24"
output: html_document
---
## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

Note that the `echo = FALSE` parameter was added to code chunks to prevent printing of the R code that generated the plot.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Output Author Affiliation Data - No Missing Author IDs

```{r}
# Goal: to create author IDs for missing cases and output back to the same dataset 

# install (for the first time only) and load packages:
#install.packages("tidyverse")
#install.packages("readxl")

library(tidyverse)
library(readxl)

# read in (or import) raw Author Affiliation Excel file:
author_affil <- read_excel("2021.09.23 Author_Affiliations.xlsx")

# create new variable (i.e., author_id2) (in a new dataframe, author-affil) where, if author_id is missing, enter the author's name for author_id; else print the existing author_id:
author_affil <- author_affil %>%
  mutate(author_id2 = case_when(is.na(author_id) ~ author_name , 
                                TRUE ~ author_id))
# check--are there any missing author_id or author_id2?:
author_affil %>%
  filter(is.na(author_id)) %>%
  select(author_id, author_id2)
author_affil %>%
  filter(is.na(author_id2)) %>%
  select(author_id, author_id2)

# output (or export) the author_affil dataframe you created to a *.csv file:
write_csv(author_affil, "2021.09.23 Author_Affiliations_no_missing_ids.csv")
```

## 3. Create Author Attribute Data

```{r}
# Goal: to reduce the recoded Author Affiliations *.csv file (see #1.) to just author name, author ID, and organizational type per author

# install (for the first time only) and load packages:
#install.packages("tidyverse")
#install.packages("readxl")

#library(tidyverse)
#library(readxl)

# read in (or import) recoded Author Affiliation *.csv file (if not already in the environment:
#author_affil <- read_csv("2021.09.23 Author_Affiliations_no_missing_ids.csv")

# Optional?: only keep pubs that are in the content analysis data set? read in the content analysis data for the publications:
#content <- read_excel("2021.09.23 Content_Analysis-CLEAN.xlsx")

# Optional? sort author affiliation dataframe by pmid variable (?):
#authors_aff <- authors_aff %>% 
#  filter(pmid %in% content$pmid)

# duplicate authors may have authored multiple papers, but we only need them once since we're only interested in the attributes of the author. create a new data set (i.e., authors_aff_unique) that is one row per author_id for cases with a single organizational type (org):
author_affil_unique <- author_affil %>%
  # select useful columns to keep in the dataframe:
    select(author_name, author_id, author_id2, author_type) %>%
  # if the following variables are distinct, then keep the values (?):
    distinct(author_id, author_id2, author_type, .keep_all = TRUE)

author_affil_unique <- author_affil_unique %>% 
# sort by the variable, author_id2:
  group_by(author_id2) %>% 
# create a variable (i.e., type_num) that numbers how many times author_id2 is in the dataframe with a unique org type:
  mutate(type_num = 1:n())
# if beyond 1, then the org type was different on different rows for the same author (e.g., author_id2 "7005932893" was listed as "academic" and "healthcare" on separate papers) 

# check--create a new dataframe (i.e., multi_type) that pulls the author_id2 of rows where the type_num value is more than 1 (that you'll need to assign a main or final type):
multi_type <- author_affil_unique %>%
  filter(type_num > 1) %>%
  select(author_id2) 

# sort the author_id2 in this dataframe (?):
 author_affil_unique %>%
  filter(author_id2 %in% multi_type$author_id2) %>%
  arrange(author_id2)

# create a new dataframe (i.e., authors_aff_wide) that pivots data to wide format, with a new column (prefixed "type") for multiple org types per author
 #(long format had extra/duplicate rows for each type per author; wide format creates one row per author with multiple types as columns) :
author_affil_wide <- author_affil_unique %>%
  pivot_wider(names_from = type_num, values_from = c(author_type), names_prefix = "type")

# factor the type1 & type2 variables in this hierarchy (i.e., community = level 1, school = level 2, etc.): 
author_affil_wide <-author_affil_wide %>%
  mutate(type1_factor = factor(type1, levels=c("Community", 
                                               "School",
                                               "Government",
                                               "Professional", 
                                               "Healthcare", 
                                               "Academic")),
         type2_factor = factor(type2, levels=c("Community", 
                                               "School",
                                               "Government",
                                               "Professional", 
                                               "Healthcare", 
                                               "Academic")))
# thus we would prioritize "healthcare" over "academic" for author "7005932893"

# create a new variable (i.e., final_type) that assigns a main org type for authors with multiple affiliations, 
# based on the following pre-determined rules:
author_affil_wide <- author_affil_wide %>%
  mutate(final_type = case_when( 
   # if only type1 value exists, then assign the value of type1:
                          is.na(type2) ~ type1,
   # if type1 value is missing but type2 exists, then assign the value of type2: 
                          is.na(type1) & !is.na(type2) ~ type2,
   # if both type1 and type2 exist, then assign based on the hierarchy of the factored variables:
                          as.numeric(type1_factor) < as.numeric(type2_factor) 
                          & (!is.na(type1) & !is.na(type2)) ~ type1,
                          as.numeric(type2_factor) < as.numeric(type1_factor)  
                          & (!is.na(type1) & !is.na(type2)) ~ type2,
                          TRUE ~ type1)) %>%
   #select useful columns to keep in the dataframe (i.e., everything but the factor variables used to compute other variables):
    select(!c("type1_factor", "type2_factor"))

# check--summarize cross-tab counts of each org type (not sure what to look for in the cross-check):
table(author_affil_wide$final_type, 
      author_affil_wide$type1,
      useNA="always")

table(author_affil_wide$final_type, 
      author_affil_wide$type2,
      useNA="always")

table(author_affil_wide$final_type, 
      author_affil_wide$type1, 
      author_affil_wide$type2,
      useNA="always")

# output (or export) the authors_aff_wide dataframe you created to a *.csv file:
write_csv(author_affil_wide, "2021.09.23 Author_Attribute_Data.csv")
```

## 2. Output Publication Data - With Dates

```{r}
# Goal: to add variables concerning date of publication and output back to the same dataset

# install (for the first time only) and load packages:
#install.packages("tidyverse")
#install.packages("readxl")
#install.packages("lubridate")

#library(tidyverse)
#library(readxl)
library(lubridate)

# read in (or import) raw Publication *.csv file:
pubs <- read_csv("2021.09.23 Publications.csv")

# optional: missing values for the variables year_cite, month, or day will result in cases failing to parse. replace NA in the variable, day, with the value of 1 before creating new variables with day:
#pubs$day[is.na(pubs$day)] <- 1

# create new variables (i.e., year_month_date, year_month, date_publish) that strings existing variables (i.e., year_cite, month, day) in YMD format, separated by single spaces:
pubs <- pubs %>% 
  mutate(year_month_date = paste(year_cite, month, day, sep= ' '),
         year_month = paste(year_cite, month, sep= ' '),
  # if day is NA, use the new year_month_day variable into YMD format:
         date_publish = case_when(!is.na(day) ~ ymd(year_month_date),
  # if day and month are NA, use the new year_month variable into YM format:
                                  is.na(day) & !is.na(month) ~ ym(year_month)) )

# create a new variable (i.e, weeks_from_start) that computes the age of RADx-UP at the time of each publication. this will be useful for summary statistics, plots, etc. at different cut points (or scales) of time.

# define 'start_date' of RADx-UP, roughly September 2020:
start_date <- "2020-08-27"

# calculate weeks from start_date:
pubs <- pubs %>%
  mutate(weeks_from_start = 
           as.numeric(difftime(date_publish, start_date, units = "weeks")))

# create a function (i.e., month_function) to define how long a "month" is (?):
month_function <- function(start_date, end_date) {
  result <- NA
  if (!is.na(end_date)){
    result <- length(seq.Date(as.Date(start_date), end_date, by = "month"))}
  result
}

# apply month_function to the dataframe (i.e., pubs) to create a new variable (i.e., months_from_start) for how many months old the pubs are:
pubs <- pubs %>%
  mutate(months_from_start = 
           as.numeric(lapply(date_publish, month_function, start_date=start_date)))

# select useful columns to keep in the dataframe 
# (i.e., everything but the YMD and YM format variables used to compute other variables):
pubs <- pubs  %>% 
  select(!c(year_month_date, year_month))

# output (or export) the pubs dataframe you created to a *.csv file:
write_csv(pubs, "2021.09.23 Publications_with_date_variables.csv")
```
## 4. Create Publication Attribute Data

```{r}
# Goal: to clean raw content analysis data and merge with recoded Publication *.csv file (see #2.) 

# install (for the first time only) and load packages:
#install.packages("tidyverse")
#install.packages("readxl")
#install.packages("lubridate")

#library(tidyverse)
#library(readxl)
#library(lubridate)

# read in raw content analysis Excel file for the publications:
content <- read_excel("2021.09.23 Content_Analysis-CLEAN.xlsx")

################################################################################

# create a new dataframe (i.e., content_recode) that renames long variables that were survey items:
content_recode <- content %>%
  rename(health_equity_addressed = `Health Equity Focus`, 
         type_of_analysis  = `Type of Analysis Identify for analytical studies whether the type of data analysis was qualitative, quantitative, both (mixed methods, literature review, or editorial.`) %>%  
  mutate(type_of_analysis = case_when(
    type_of_analysis == "N/A" ~ as.character(NA),
    TRUE ~ type_of_analysis)) 

# check--summarizes counts of each type of analysis (make sure it sums up to the number of papers in the analytical dataset):
table(content_recode$type_of_analysis)

################################################################################

# create a new variable that recodes the dichotomous/check-all column options into a single categorical variable (i.e., UP_urban_rural).
# then create additional dichotomous variables (i.e., target_pop_urban, target_pop_rural), based on the created urban_rural variable so that "Both" counts as "target_pop_urban" and as "target_pop_rural":
content_recode <- content_recode %>% 
  rename(Rural = Rural...29) %>%
  mutate(UP_urban_rural = case_when( 
                                  (Rural == 1 & Urban==1) ~ "Both",
                                  (Rural == 0 & Urban==1) ~ "Urban",
                                  (Rural == 1 & Urban==0) ~ "Rural",
                                  (Rural == 0 & Urban==0) ~ as.character(NA)),
         target_pop_urban = case_when(
           UP_urban_rural %in% c("Both","Urban") ~ 1,
           TRUE ~ 0),
         target_pop_rural = case_when(
           UP_urban_rural%in% c("Both","Rural") ~ 1,
           TRUE ~ 0))

# check--summarizes cross-tab counts of new categorical variable to previous dichotomous variables:
table(content_recode$UP_urban_rural, 
      content_recode$Urban, content_recode$Rural)

table(content_recode$Urban, 
      content_recode$target_pop_urban)

table(content_recode$Rural,
      content_recode$target_pop_rural)

################################################################################

# create a new variable that recodes the dichotomous/check-all column options into a single categorical variable (i.e., UP_age):
content_recode <- content_recode %>%
  mutate(UP_age = case_when(
         `Children and adolescents (< 18 yo)` == 1 ~ "UP_children",
         `Older Adults`  == 1 ~ "UP_elders",
          TRUE ~ "not_UP_age")) %>%
# rename the dichotomous/check-all columns:
  rename(target_pop_children = `Children and adolescents (< 18 yo)`, 
         target_pop_elders = `Older Adults` )

# check--summarizes cross-tab counts of new categorical variable to previous dichotomous variables:
table(content_recode$UP_age,
      content_recode$target_pop_children)

table(content_recode$UP_age,
      content_recode$target_pop_elders)

################################################################################

# create a new variable that recodes the dichotomous/check-all column options into a single categorical variable (i.e., UP_SES): 
content_recode <- content_recode %>%
  mutate(UP_SES = case_when(
    `Low socioeconomic status` == 1 ~ "UP_low_SES",
    `Low socioeconomic status` == 0 ~ "not_UP_SES")) %>%
# rename the dichotomous/check-all columns:
  rename(target_pop_SES = `Low socioeconomic status`)

# check--summarizes cross-tab counts of new categorical variable to previous dichotomous variables:
table(content_recode$UP_SES,
      content_recode$target_pop_SES)

################################################################################

# create a new variable that recodes the dichotomous/check-all column options into a single categorical variable (i.e., UP_HCW):
content_recode <- content_recode %>%
  mutate(UP_HCW = case_when(
    `Health care worker` == 1 ~ "UP_healthcare_worker",
    `Health care worker` == 0 ~ "not_UP_healthcare_worker")) %>%
# rename the dichotomous/check-all columns:
  rename(target_pop_HCW = `Health care worker`)

# check--summarizes cross-tab counts of new categorical variable to previous dichotomous variables:
table(content_recode$UP_HCW,
      content_recode$target_pop_HCW)

################################################################################

# create a new variable that recodes the dichotomous/check-all column options into a single categorical variable (i.e., UP_teacher):
content_recode <- content_recode %>%
  mutate(UP_teacher = case_when(
    Teacher == 1 ~ "UP_teacher",
    Teacher == 0 ~ "not_UP_teacher")) %>%
# rename the dichotomous/check-all columns:
  rename(target_pop_teacher = Teacher)

# check--summarizes cross-tab counts of new categorical variable to previous dichotomous variables:
table(content_recode$UP_teacher, 
      content_recode$target_pop_teacher)

################################################################################

# create a new variable that recodes the dichotomous/check-all column options into a single categorical variable (i.e., UP_race):
content_recode <- content_recode %>%
  mutate(UP_race = case_when( 
    (`Asian American` == 1 |
     `Native Hawaiian` == 1 |
     `Pacific Islander` == 1) & 
     `Black or African American` == 0 & 
     `Hispanic or Latino`== 0 ~ "UP_Asian",
    
    (`American Indian` == 1 |
     `Alaska Native` == 1) & 
     `Black or African American` == 0 & 
     `Hispanic or Latino`== 0 ~ "UP_Indigenous",
    
     `Black or African American` == 1 & 
     `Hispanic or Latino` == 0 ~ "UP_Black",
    
     `Black or African American` == 0 & 
     `Hispanic or Latino` == 1 ~ "UP_Latinx",
    
     `Black or African American` == 1 & 
     `Hispanic or Latino` == 1 & 
     `American Indian` == 0 & 
     `Asian American` == 0 ~ "UP_Black Latinx",
    
     `Black or African American` == 1 & 
     `Hispanic or Latino` == 1 & 
     `American Indian` == 1 & 
     `Asian American` == 0 ~ "UP_Black Indigenous Latinx",
    
     `Black or African American` == 1 &
     `Hispanic or Latino` == 1 & 
     `Asian American` == 1 &
     `American Indian` == 0 ~ "UP_Black Latinx Asian",
    
      TRUE ~ "no_race_target"),
         
    target_race_binary = case_when(
      UP_race == "no_race_target" ~ 0,
      TRUE ~ 1)) %>%
# rename the dichotomous/check-all columns:
  rename(target_pop_Black = `Black or African American`,
         target_pop_Latinx = `Hispanic or Latino`,
         target_pop_Indigenous = `American Indian`,
         target_pop_Asian = `Asian American`)

# check--summarizes cross-tab counts of new categorical variable to previous dichotomous variables:
table(content_recode$UP_race,
      content_recode$target_pop_Black)

table(content_recode$UP_race,
      content_recode$target_pop_Latinx)

table(content_recode$UP_race, 
      content_recode$target_pop_Indigenous)

table(content_recode$UP_race, 
      content_recode$target_pop_Asian)

table(content_recode$UP_race, 
      content_recode$target_race_binary)

################################################################################

# create a new dataframe (i.e., site_recode) that keeps and renames dichotomous/check-all variables:
site_recode <- content_recode %>%
  select(community_health_center = `Community health center`,
         hospital = `Hospital` ,
         in_home = `In-home` ,
         prison = `Prison/jail` ,
         care_facility = `Residential care facility`,
         school = `School` ,
         other = `Other Setting 1`) %>%
  mutate(hospital = case_when(
           other == "university-based hospital system" ~ 1,
           TRUE ~ hospital),
    
         community_events = case_when(
           other %in% c("Community organization",
                        "Free community-based Latino testing events",
                        "Street outreach") ~ 1 ,
           TRUE ~ 0),
         
         vaccination_sites = case_when(
           other %in% c("Vaccination sites: churches, clinics, and community events were the COVID-19 vaccine was being administered",
                        "Vaccination sites [outpatient primary care clinics, churches, community events, and outdoor vaccination drive through locations]") ~ 1 ,
           TRUE~0),
         
         other = case_when(
           is.na(other) | 
           hospital == 1 | 
           community_events == 1|
           vaccination_sites == 1 ~ 0,
           !is.na(other) ~ 1))

# create a function (i.e., which_site) to help with recoding... (?):
which_site <- function(x, y){names(which(x==y))[1]}

#here we locate which column (e.g., community health center, school, etc.)
#there is a value of 1 and grab the column's name for the new categorical variable, study_site 

site_recode <- site_recode  %>%
  mutate(study_site = apply(site_recode, 1, which_site, y = 1))

# note that a few publications had multiple sites
# "community_health_center" "other": coded as community_health_center
# "hospital"      "care_facility": coded as hospital

# add the categorical study_site variable to the content_recode dataframe:
content_recode <- content_recode %>% 
  mutate(study_site = site_recode$study_site)

#quick check:
table(content_recode$study_site, 
      content_recode$`School`)

table(content_recode$study_site, 
      content_recode$`Community health center`)

################################################################################

# create a new dataframe (i.e., design_recode) that keeps and renames dichotomous/check-all variables:
design_recode <- content_recode %>%
  select(experimental = `Experimental`,
         quasi_experimental = `Quasi-Experimental` ,
         simulation = `Simulation` ,
         observational = `Observational` ,
         evaluation = `Evaluation` ,
         formative = `Formative/exploratory`,
         dissemination = `Dissemination & implementation`,
         cost_benefit = `Cost-benefit` ,
         quant_other = `Other Quantitative Method`,
         focus_group = `Focus group` ,
         interview = `Interview`,
         survey = `Survey`,
         qual_other = `Other Qualitative`)

# create a function (i.e., which_design) to help with recoding... (?):
which_design <-function(x, y){paste(names(which(x==y)), collapse = ".")}

# here, we take each study design, note if the pub used it and paste it with other study design types, since studies can have multiple study designs (?)

design_recode <- design_recode  %>%
  mutate(study_design = apply(design_recode , 1, which_design, y = 1) ,
         study_design = case_when(
           study_design == "" ~ "no_study_design",
           TRUE ~ study_design))

# bind the whole design_recode dataframe to the content_recode dataframe:
content_recode <- bind_cols(content_recode, design_recode,
                            .name_repair = "minimal")

#quick check:
table(design_recode$study_design, 
      design_recode$observational)

################################################################################

# create a new dataframe (i.e., engage_recode) that keeps and renames dichotomous/check-all variables and dummies comments in "other":
engage_recode <- content_recode %>%
  select(engage_broadcast_media = `Broadcast media (e.g., press conferences, TV interviews`,
         engage_entertainment = `Entertainment activities (e.g., picnics, raffles` ,
         engage_focus_groups = `Focus groups and/or surveys` ,
         engage_meetings_events = `In-person or online community presentations or meetings (professional or educational events` ,
         engage_social_media = `Internet/social media (e.g., email blast, blog, Facebook, YouTube`,
         engage_partnerships = `Partnerships with community-based organizations` ,
         engage_print_media = `Print media (e.g., press releases, newspaper articles`,
         engage_other1 = `Other Community Engagement 1`,
         engage_other2 = `Other Community Engagement 2`) %>%
  mutate(engage_advisory_board = case_when(
           engage_other1 %in% c("ad-hoc advisory group of community leaders in each SYCT county todevelop a community-informed strategy for distribution of at-home test kits",
                                "Community Advisory Boards") ~ 1, 
                                TRUE ~ 0),
         engage_peer_influence = case_when(
           engage_other1 %in% c("Identifying frontline champions",
                                "Peer influencers",
                                "Community member referral networks") ~ 1, 
                                 TRUE ~ 0),
         engage_transportation = case_when(
           engage_other1 %in% c("Street outreach; mobile vans",
                                "transportation to vaccination sites;  a network of public health/clinical health service providers to provide vaccinations; widespread vaccinations sites (ex. malls; removal of residential status as a barrier to obtain vaccines; public health worker delivery of vaccines in rural areas") ~ 1, 
                                 TRUE ~ 0),
         engage_partnerships = case_when(
           engage_other1 %in% c("COVID-19 data collection through the partnership for decision-making",
                                "Multi-disciplinary  collaborative  research and partnerships  focused  on  addressing community needs and building a translational science workforce to enhance project implementation and reach; faculty  members  engage  closely  with  local  health  departments,",
                                "Conducted an Asian-American and Native Hawaiian/Pacific Islander COVID-19 Needs Assessment") ~ 1,
                                TRUE ~ engage_partnerships),
         engage_meetings_events = case_when(
           engage_other1 %in% c("Free community-based Latino testing events") ~ 1,
                                TRUE ~ engage_meetings_events),
         engage_other1 = case_when(
           is.na(engage_other1) | 
           engage_advisory_board == 1 |
           engage_peer_influence == 1 |
           engage_partnerships == 1 |
           engage_meetings_events == 1 |
           engage_transportation == 1 ~ 0,
           !is.na(engage_other1) ~ 1),
         engage_other2 = case_when(is.na(engage_other2) ~ 0,
           !is.na(engage_other2) ~ 1))
 
engage_recode <- engage_recode   %>%
  mutate(engage_number = apply(engage_recode[, ], 1, sum),
         engage_binary = 1 * (engage_number > 0),
         cmty_engage = apply(engage_recode, 1, which_design, y = 1),
         cmty_engage = case_when(
           cmty_engage == " " ~ "no_engagement",
           TRUE ~ cmty_engage))

print(engage_recode, width=100000, n =15)

table(engage_recode$cmty_recode)

table(engage_recode$cmty_recode, 
      engage_recode$engage_binary)

# bind the whole design_recode dataframe to the content_recode dataframe:
content_recode <- bind_cols(content_recode, engage_recode,
                            .name_repair = "minimal")

################################################################################

# TSBM (translational science benefits model): vaccines

# need to create 4 basic variables of 1 = did translational science model
# and 0 = did not do it
# then create variable of combinations, number of TSMB as well as binary indicator

# here for vaccines

# here we recode the main variables for clinical, public health, economic
# and policy. recode so that a 1 is did that benefit and 0 otherwise 

content_recode <- content_recode %>%
  mutate(
    TSBM_vaccines_clinical = case_when(
      (`Vaccination Clinical Guidelines` == 1 |
       `Vaccination Procedures` == 1 |
       `Vaccine Technology`== 1) ~ 1,
        TRUE ~ 0),
    TSBM_vaccines_public_health = case_when(
      (`Community Vaccination Services` == 1 |
       `Vaccine Education Resources` == 1 |
       `Vaccination Accessibility`== 1|
       `Vaccine Delivery and Uptake`== 1|
       `Vaccine Hesitancy`== 1|
       `Software and Digital Health for Vaccination`==1|
       `Public Health Vaccination Practices`==1) ~ 1,
        TRUE ~ 0),
   TSBM_vaccines_economic = case_when(
     (`Vaccine License Agreements and Patents` == 1 |
      `Vaccine Non-Profit or Commercial Entities` == 1 |
      `Vaccine Cost Effectiveness`== 1|
      `Vaccine Cost Savings`== 1) ~ 1,
      TRUE ~ 0),
  TSBM_vaccines_policy = case_when(
    (`Vaccination Advisory Activities` == 1 |
     `Vaccination Policies and Legislation` == 1) ~ 1,
      TRUE ~ 0))

#now creating extra variables, number of TSBM benefits, pasted together
#benefits they did and binary indicator if did any benefit

TSBM_vaccine_columns <- c("TSBM_vaccines_clinical", 
                          "TSBM_vaccines_public_health",
                          "TSBM_vaccines_economic", 
                          "TSBM_vaccines_policy")

content_recode <- content_recode   %>%
  mutate(TSBM_vaccines_number = apply(content_recode[, TSBM_vaccine_columns], 1, sum),
         TSBM_vaccines_binary = 1 * (TSBM_vaccines_number > 0),
         TSBM_vaccines_recode = apply(content_recode[, TSBM_vaccine_columns], 1, which_design, y = 1) ,
         TSBM_vaccines_recode = case_when(TSBM_vaccines_recode == "" ~ "no_TSBM_vaccines",
                                             TRUE ~ TSBM_vaccines_recode))

#quick check:
print(content_recode[,c(TSBM_vaccine_columns, 
                        "TSBM_vaccines_binary", 
                        "TSBM_vaccines_recode", 
                        "TSBM_vaccines_number")],
      width=1000)


table(content_recode$TSBM_vaccines_binary, 
      content_recode$TSBM_vaccines_number)

table(content_recode$TSBM_vaccines_binary, 
      content_recode$TSBM_vaccines_recode)

################################################################################

# TSBM (translational science benefits model): testing

content_recode <- content_recode %>%
  mutate(
    TSBM_testing_clinical = case_when(
      (`Testing Clinical Guidelines` == 1 |
       `Testing Procedures` == 1 |
       `Testing Technology`== 1) ~ 1,
        TRUE ~ 0),
    TSBM_testing_public_health = case_when(
      (`Community Testing Services` == 1 |
       `Testing Education Resources` == 1 |
       `Testing Accessibility`== 1|
       `Testing Hesitancy`== 1|
       `Software and Digital Health for Testing`== 1|
       `Public Health Testing Practices`== 1) ~ 1,
        TRUE ~ 0),
    TSBM_testing_economic = case_when(
      (`Testing License Agreements and Patents` == 1 |
       `Testing Non-Profit or Commercial Entities` == 1 |
       `Testing Cost Effectiveness`== 1|
       `Testing Cost Savings`== 1) ~ 1 ,
        TRUE ~ 0),
    TSBM_testing_policy = case_when(
      (`Testing Advisory Activities` == 1 |
       `Testing Policies and Legislation` == 1) ~ 1,
        TRUE ~ 0) )

#now creating extra variables, number of TSBM benefits, pasted together
#benefits they did and binary indicator if did any benefit

TSBM_testing_columns <- c("TSBM_testing_clinical", 
                          "TSBM_testing_public_health",
                          "TSBM_testing_economic",
                          "TSBM_testing_policy")

content_recode  <- content_recode   %>%
  mutate(TSBM_testing_number = apply(content_recode[, TSBM_testing_columns], 1, sum),
         TSBM_testing_binary = 1 * (TSBM_testing_number > 0),
         TSBM_testing_recode = apply(content_recode[, TSBM_testing_columns], 1, which_design, y = 1) ,
         TSBM_testing_recode = case_when(TSBM_testing_recode == "" ~ "no_TSBM_vaccines",
                                          TRUE ~ TSBM_testing_recode))

#quick check:
print(content_recode[, c(TSBM_testing_columns, 
                         "TSBM_testing_binary", 
                         "TSBM_testing_recode", 
                         "TSBM_testing_number")],
      width=1000)

table(content_recode$TSBM_testing_binary, 
      content_recode$TSBM_testing_number)

table(content_recode$TSBM_testing_binary, 
      content_recode$TSBM_testing_recode)

#rename some health variables

content_recode <- content_recode %>% 
  rename(Neurological = `Neurological disorders (includes Guillain-Barre syndrome)`,
         HIV = `HIV/AIDS`,
         HepC = `Hepatitis C`,
         Diabetes = `Diabetes, Hyperglycemia or Hypoglycemia`)

#reduce to key variables of interest:

vars <- c("pmid", 
          "UP_urban_rural", 
          "type_of_analysis" ,
          "health_equity_addressed", 
          "UP_age",
          "target_pop_children", 
          "target_pop_elders", 
          "UP_SES", 
          "target_pop_SES",
          "UP_HCW", 
          "target_pop_HCW", 
          "UP_teacher", 
          "target_pop_teacher",
          "target_pop_urban", 
          "target_pop_rural",
          "UP_race", 
          "target_race_binary",
          "target_pop_Black", 
          "target_pop_Latinx", 
          "target_pop_Indigenous", 
          "target_pop_Asian",
          "study_site", 
          colnames(design_recode),
          colnames(community_engage), 
          TSBM_vaccine_columns, 
          "TSBM_vaccines_binary", 
          "TSBM_vaccines_recode", 
          "TSBM_vaccines_number",
          TSBM_testing_columns, 
          "TSBM_testing_binary", 
          "TSBM_testing_recode", 
          "TSBM_testing_number",
          "Neurological",  
          "HIV", 
          "HepC", 
          "Diabetes", 
          "Obesity", 
          "Preeclampsia")

 content_recode <- content_recode %>% 
   select(all_of(vars))
 
################################################################################

# read in (or import) recoded Publication *.csv file:
pubs <- read_csv("2021.09.23 Publications_with_date_variables.csv") %>%
# duplicate PMIDs may be associated more than one project, but we only need them once since we're only interested in the attributes of the paper. if the following variables are distinct (i.e., unique PubMed ID numbers), then keep the values (?):
  distinct(pmid, .keep_all = T)

pubs <- pubs %>% 
  # select useful columns to keep in the dataframe:
  select(cycle, year_cite, month, day, 
         date_publish, weeks_from_start, months_from_start, pmid, title)

################################################################################

# merge content analysis data onto publication data and export

publication_attributes <- left_join(x = content_recode, y = pubs, by = "pmid")

#only keep publication if on pub-author edgelist?
temp_edges <- read_csv("2021.09.23 Author_Affiliations_no_missing_ids.csv")

# sort pub dataframe by pmid variable (?):
publication_attributes <- publication_attributes  %>%
  filter(pmid %in% temp_edges$pmid)

# output (or export) the publication_attributes dataframe you created to a *.csv file:
write_csv(publication_attributes, "2021.09.23 Publication_Attribute_Data.csv")
```
## 5. Create Author-Publication Edgelist

```{r}
# Goal: to merge recoded Author Affiliations *.csv file (see #1.) with recoded Publication *.csv file (see #2.)

# install (for the first time only) and load packages:
#install.packages("tidyverse")
#install.packages("readxl")
#install.packages("lubridate")

#library(tidyverse)
#library(readxl)
#library(lubridate)

# read in (or import) recoded Author Affiliation *.csv file:
#author_affil <- read_csv("2021.09.23 Author_Affiliations_no_missing_ids.csv")

#select useful columns to keep in the dataframe (i.e., just PMIDs & author IDs):
author_affil <- author_affil %>%
  select(pmid, author_id, author_id2)

# read in (or import) recoded Publication *.csv file and merge key edge attributes on the publication onto the edgelist: 
pubs <- read_csv("2021.09.23 Publications_with_date_variables.csv") %>%
  distinct(pmid, .keep_all = TRUE)
# duplicate PMIDs may be associated more than one project, but we only need them once since we're only interested in the attributes of the paper. if the following variables are distinct (i.e., unique PubMed ID numbers), then keep the values.

#select useful columns to keep in the dataframe:
pubs <- pubs %>% 
  select(proj_num, cycle, year_cite, month, day, date_publish, weeks_from_start, months_from_start, pmid)

# create a new dataframe (i.e., author_pub_edgelist) that uses left_join to map edge attributes from pubs into the edgelist, based on PMIDs as the identifier:
author_pub_edgelist <- left_join(x = author_affil, y = pubs, by = "pmid")

# reorder the columns:
author_pub_edgelist <- author_pub_edgelist %>% 
  select(author_id2, pmid, cycle:months_from_start, author_id)

# only keep pubs that are in the content analysis data set? read in the content analysis data for the publications:
#content <- read_excel("2021.09.23 Content_Analysis-CLEAN.xlsx")

# sort edgelist dataframe by pmid variable (?):
#author_pub_edgelist <- author_pub_edgelist %>% 
#  filter(pmid %in% content$pmid)

# output (or export) the author_pub_edgelist dataframe you created to a *.csv file:
write_csv(author_pub_edgelist, "2021.09.23 Author_Pub_Edgelist.csv")
```

## 6. Optional: Create Project-Publication List

```{r}
# Goal: to output a list showing which projects are associated with each publication (pmid)

# install (for the first time only) and load packages
#install.packages("tidyverse")
#install.packages("readxl")
#install.packages("lubridate")

#library(tidyverse)
#library(readxl)
#library(lubridate)

# read in (or import) recoded Publications *.csv file 
#pubs <- read_csv("2021.09.23 Publications_with_date_variables.csv")

# only keep pubs that are in the content data set? read in the content analysis data for the publications:
#content <- read_excel("2021.09.23 Content_Analysis-CLEAN.xlsx")

# sort pubs dataframe by pmid variable (?):
pubs <- pubs %>% 
  filter(pmid %in% content$pmid)

# create a function (i.e., which_proj) to grab the project number, for a given variable (e.g., pmid):
which_proj <- function(dat, var, id){
    dat$proj_num[dat[, var] == id]
  }

# define unique set of pmids
pmids <- unique(pubs$pmid)

# create a data frame (?) (i.e., list_of_projects) that grabs all projects associated with a pmid 
list_of_projects <- lapply(pmids, which_proj, dat = pubs, var = "pmid")
### not sure what to do with missing column: Warning: Unknown or uninitialised column: `proj_num`.

names(list_of_projects) <- pmids

# save out list of projects for each pmid:
save(list_of_projects, file = "2021.09.23 Project_Publication_List.Rdata")

# optional checks:
View(list_of_projects)
list_of_projects [[1]] #project number for the first PMID?
```

## 7. Create Co-Authorship Network--finally!

```{r}
# Goal: to construct basic igraph objects with:
# Author_Attribute_Data.csv (see #3.)
# Publication_Attribute_Data.csv (see #4.)
# Publication_Author_Edgelist.csv (see #5.)

# install (for the first time only) and load packages:
#install.packages("tidyverse")
#install.packages("igraph")

#library(tidyverse)
library(igraph)

# read in (or import) recoded Author Attribute *.csv file:
author_affil_wide <- read_csv("2021.09.23 Author_Attribute_Data.csv")
col_type = cols(author_id2 = col_character())

# read in (or import) recoded Publication Attribute *.csv file and set pmid to character:
publication_attributes <- read_csv("2021.09.23 Publication_Attribute_Data.csv")
                                   col_type = cols(pmid = col_character())

#read in (or import) recoded Edgelist *.csv files and set pmid to character:
author_pub_edgelist <- read_csv("2021.09.23 Author_Pub_Edgelist.csv")
                                   col_type = cols(pmid = col_character()) 

#######
# First a bit of compiling of input data before constructing the networks

# Putting together a combined data set of publication and author attributes

# first, making a single id and type variable and putting it on publication and
# author attribute data frames

# publication first: copying the PMID as an ID

publication_attributes <- publication_attributes  %>%
  mutate(ids = pmid, type = "publication")

# and now author

author_affil_wide <- author_affil_wide  %>%
  mutate(ids = author_id2, type = "author")

# and now we create a shared data.frame, where stacking author attributes on top of
# publication attributes into a single data.frame

# first we define which attributes are shared across the two data.frames

shared_var_names <- c("ids", "type")

#now append/ created stacked data with authors on top without same col
stacked.df <- bind_rows(author_affil_wide %>% select(all_of(shared_var_names)), 
                    publication_attributes %>% select(all_of(shared_var_names)) )

# And now let's move to the author specific attributes, putting in NAs for the publications

temp_pub_data <- author_affil_wide[1, ]
temp_pub_data[1, ] <- NA
temp_pub_data_NA <- tibble(temp_pub_data, .rows = nrow(publication_attributes))

# put together author and publication data for author specific attributes,
# excluding the shared ones

author_specific <- bind_rows(author_affil_wide %>% select(-shared_var_names), 
                             temp_pub_data_NA %>%select(-shared_var_names))

# and now the reverse, doing publication specific attributes
temp_author_data <- pubs[1, ]
temp_author_data[1, ] <- NA
temp_author_data_NA <- tibble(temp_author_data, .rows = nrow(author_affil_wide))

#no ids and type for bind_rows
#publication_specific <- bind_rows(temp_author_data_NA %>% select(-shared_var_names),
#                                  pubs %>% select(-shared_var_names))

publication_specific <- bind_rows(temp_author_data_NA,
                                  pubs)


#and now putting all together

attributes_authors_publications  <- bind_cols(stacked.df, author_specific,
                                              publication_specific)

# and let's also add sender/receiver vars in the edgelist for convenience:
# sender is author (author_id2), and receiver publication (pmid).

author_pub_edgelist <- author_pub_edgelist %>% 
  mutate(sender = author_id2, receiver = pmid) %>%
  select(sender, receiver, cycle:author_id, author_id2, pmid)

# Constructing the Network
# Here we take the edgelist, two attribute files and construct the igraph object
# useful for plotting and summary statistics.


# Let's create a 'named' type vector, showing if node is author or publication
# with name set to id
attributes_authors_publications <- attributes_authors_publications %>%
  mutate(type_binary = 1*(type == "publication"))
#logical of publication and author to print back 1=true/pub or 0=false/auth in a new col (type_binary)

type <- attributes_authors_publications$type_binary
names(type) <- attributes_authors_publications$ids
#named vector of author_ID & PMIDs with true/false ones and zeroes

# now creating network in igraph, with types set to type and edges
# grabbed from sender/receiver columns, need to transpose and make the 2 column
# matrix a vector to get in format for igraph: 

# take out any edges that are not in attribute file?
#author_publication_edgelist <- author_publication_edgelist %>%
#  filter(sender %in% names(type) & receiver %in% names(type))

edges <- c(t(author_pub_edgelist %>% select(sender, receiver)))
#vector of PMIDs

coauthorship_net <- make_bipartite_graph(types = type, edges = edges)
coauthorship_net <- make_bipartite_graph(types = type, edges = test)

#check to make this sure this looks right and grab useful indicator vectors:

type_from_igraph <- V(coauthorship_net)$type
table(type_from_igraph)

#identify which are authors
is_author_type <- type_from_igraph == FALSE

#identify which are publications
is_publication_type <- type_from_igraph == TRUE

# Putting attributes onto object:

coauthorship_net <- set_vertex_attr(graph = coauthorship_net, 
                                   name = "org_final", 
                                   value = attributes_authors_publications$org_final)

#getting name of publication as a vertex attribute
coauthorship_net <- set_vertex_attr(graph = coauthorship_net, 
                                    name = "title", 
                                    value = attributes_authors_publications$title)

# saving out network and combined attribute file


save(coauthorship_net, attributes_authors_publications, 
     file = paste(wd, "network_inputs/", date,  
                  " Coauthorship Network igraph.Rdata", sep = ""))





```

## 8.

```{r}

```

## 9.

```{r}

```

## 10.

```{r}

```

## 11.

```{r}

```