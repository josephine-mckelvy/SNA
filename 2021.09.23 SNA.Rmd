---
title: "Network Analysis for RADx-UP Scientific Collaboration (or coauthorship)"
author: "Josephine McKelvy"
date: "2023-01-24"
output: html_document
---
## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

Note that the `echo = FALSE` parameter was added to code chunks to prevent printing of the R code that generated the plot.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Output Author Affiliation Data - No Missing Author IDs

```{r}
# Goal: to create author IDs for missing cases and output back to the same dataset 

# install (for the first time only) and load packages:
#install.packages("tidyverse")
#install.packages("readxl")

library(tidyverse)
library(readxl)

# read in (or import) raw affiliation excel file:
authors_aff <- read_excel("2021.09.23 Author_Affiliations.xlsx")

# create new variable (i.e., author_id2) where, if author_id is missing, enter the author's name for author_id; else print the existing author_id:
authors_aff <- authors_aff %>%
  mutate(author_id2 = case_when(is.na(author_id) ~ author_name , 
                                TRUE ~ author_id))
# check:
authors_aff %>%
  filter(is.na(author_id)) %>%
  select(author_id, author_id2)
authors_aff %>%
  filter(is.na(author_id2)) %>%
  select(author_id, author_id2)

# output (or export) the authors_aff dataframe you created to a *.csv file:
write_csv(authors_aff,"2021.09.23 Author_Affiliations_no_missing_ids.csv")
```

## 2. Output Publication Data - With Dates

```{r}
# Goal: to add variables concerning date of publication and output back to the same dataset

# install (for the first time only) and load packages:
#install.packages("tidyverse")
#install.packages("readxl")
#install.packages("lubricate")

#library(tidyverse)
#library(readxl)
library(lubridate)

# read in (or import) raw publication *.csv file:
pubs <- read_csv("2021.09.23 Publications.csv")

# optional: missing values for the variables year_cite, month, or day will result in cases failing to parse. replace NA in the variable, day, with the value of 1 before creating new variables with day:
#pubs$day[is.na(pubs$day)] <- 1

# create new variables (i.e., year_month_date, year_month, date_publish) that strings existing variables (i.e., year_cite, month, day) in YMD format, separated by single spaces:
pubs <- pubs %>% 
  mutate(year_month_date = paste(year_cite, month, day, sep= ' '),
         year_month = paste(year_cite, month, sep= ' '),
  # if day is NA, use the new year_month_day variable into YMD format:
         date_publish = case_when(!is.na(day) ~ ymd(year_month_date),
  # if day and month are NA, use the new year_month variable into YM format:
                                  is.na(day) & !is.na(month) ~ ym(year_month)) )

# create a new variable (i.e, weeks_from_start) that computes the age of RADx-UP at the time of each publication. this will be useful for summary statistics, plots, etc. at different cut points (or scales) of time.

# define 'start_date' of RADx-UP, roughly September 2020:
start_date <- "2020-08-27"

# calculate weeks from start_date:
pubs <- pubs %>%
  mutate(weeks_from_start = 
           as.numeric(difftime(date_publish, start_date, units = "weeks")))

# create a function (i.e., month_function) since months have varying lengths:
month_function <- function(start_date, end_date) {
  result <-NA
  if (!is.na(end_date)){
    result <-  length(seq.Date(as.Date(start_date), end_date, by = "month"))}
  result
}

# apply month_function to the dataframe (i.e., pubs):
pubs <- pubs %>%
  mutate(months_from_start = 
           as.numeric(lapply(date_publish, month_function, start_date=start_date)))

# select columns to keep in the dataframe (i.e., everything but the YMD and YM format variables used to compute other variables):
pubs <- pubs  %>% 
  select(!c(year_month_date, year_month))

# output (or export) the pubs dataframe you created to a *.csv file:
write_csv(pubs,"2021.09.23 Publications_with_date_variables.csv")
```

## 3. Create Author Attribute Data

```{r}
# Goal: to reduce the recoded Author Affiliations *.csv file (see #1.) to just author name, author ID, and organizational type per author

# install (for the first time only) and load packages:
#install.packages("tidyverse")
#install.packages("readxl")

#library(tidyverse)
#library(readxl)

# read in (or import) recoded affiliation *.csv file:
authors_aff <- read_csv("2021.09.23 Author_Affiliations_no_missing_ids.csv")

# read in the content analysis data for the publications (not sure why):
#content <- read_excel("2021.09.23 Content_Analysis-CLEAN.xlsx")

# sort content dataframe by pmid variable (?):
#authors_aff <- authors_aff %>% 
#  filter(pmid %in% content$pmid)

# duplicate authors may have authored more than one paper, but we only need them once since we're only interested in the attributes of the author. create a new data set (i.e., authors_aff_unique) that is one row per author_id for cases with a single organizational type (org):
authors_aff_unique <- authors_aff %>%
# select columns to keep in the dataframe:
    select(author_name, author_id, author_id2, author_type) %>%
# if the following variables are distinct, then keep the values (?):
    distinct(author_id, author_id2, author_type, .keep_all = TRUE)

authors_aff_unique <- authors_aff_unique %>% 
# sort by the variable, author_id2:
  group_by(author_id2) %>% 
# create a variable (i.e., type_num) that numbers how many times author_id2 is in the dataframe with a distinct org type:
  mutate(type_num = 1:n())
# if beyond 1, then the org type was different on different rows for the same author (e.g., author_id2 "7005932893" was listed as "academic" and "healthcare" on separate papers) 

# check--create a new dataframe (i.e., multiple_ids) that pulls the author_id2 of rows where the type_num value is more than 1:
multiple_ids <- authors_aff_unique %>%
  filter(type_num > 1) %>%
  select(author_id2) 

# sort the author_id2 in this dataframe (?):
 authors_aff_unique %>%
  filter(author_id2 %in% multiple_ids$author_id2) %>%
  arrange(author_id2)

# create a new dataframe (i.e., authors_aff_wide) that pivots data to wide format, with a new column (prefixed "type") for multiple org types per author:
authors_aff_wide <- authors_aff_unique %>%
  pivot_wider(names_from = type_num, values_from = c(author_type), names_prefix = "type")

# factor the type1 & type2 variables in this hierarchy (i.e., community = level 1, school = level 2, etc.): 
authors_aff_wide <-authors_aff_wide %>%
  mutate(type1_factor = factor(type1, levels=c("Community", 
                                               "School",
                                               "Government",
                                               "Professional", 
                                               "Healthcare", 
                                               "Academic")),
         type2_factor = factor(type2, levels=c("Community", 
                                               "School",
                                               "Government",
                                               "Professional", 
                                               "Healthcare", 
                                               "Academic")))
# thus we would prioritize "healthcare" over "academic" for author "7005932893"

# create a new variable (i.e., org_final) that assigns a main org type for authors with multiple affiliations, 
# based on the following pre-determined rules:
authors_aff_wide <- authors_aff_wide %>%
  mutate(org_final = case_when( 
   # if only type1 value exists, then assign the value of type1:
                          is.na(type2) ~ type1,
   # if type1 value is missing but type2 exists, then assign the value of type2: 
                          is.na(type1) & !is.na(type2) ~ type2,
   # if both type1 and type2 exist, then assign based on the hierarchy of the factored variables:
                          as.numeric(type1_factor) < as.numeric(type2_factor) 
                          & (!is.na(type1) & !is.na(type2)) ~ type1,
                          as.numeric(type2_factor) < as.numeric(type1_factor)  
                          & (!is.na(type1) & !is.na(type2)) ~ type2,
                          TRUE ~ type1)) %>%
#select columns to keep in the dataframe (i.e., everything but the factor variables used to compute other variables):
    select(!c("type1_factor", "type2_factor"))

# check--summarize cross-tab counts of each org type (not sure what to look for in the cross-check):
table(authors_aff_wide$org_final, authors_aff_wide$type1,
      useNA="always")

table(authors_aff_wide$org_final, authors_aff_wide$type2,
      useNA="always")

table(authors_aff_wide$org_final, authors_aff_wide$type1, authors_aff_wide$type2,
      useNA="always")

# output (or export) the authors_aff_wide dataframe you created to a *.csv file:
write_csv(authors_aff_wide, "2021.09.23 Author_Attribute_Data.csv")

# author_id is id of author, with some NAs
# author_id2 is id of author with no NAs (name put in where NA in author_id)
# author is name of author
# org1 is first org type (most authors only have 1)
# org2 is second org type (if relevant)
# org_final is combined, single org type for author based on filling
# missing data where exists and hierarchy of org types (see above)
```

## 4. Create Publication Attribute Data

```{r}
# Goal: to clean raw content analysis data and merge with recoded publication *.csv file (see #2.) 

# install (for the first time only) and load packages:
#install.packages("tidyverse")
#install.packages("readxl")
#install.packages("lubricate")

#library(tidyverse)
#library(readxl)
#library(lubridate)

# read in the content analysis data for the publications:
content <- read_excel("2021.09.23 Content_Analysis-CLEAN.xlsx")

################################################################################

# create a new dataframe (i.e., content_recode) that renames long variables that were survey items:
content_recode <- content %>%
  rename(health_equity_addressed = `Health Equity Focus`, 
         type_of_analysis  = `Type of Analysis Identify for analytical studies whether the type of data analysis was qualitative, quantitative, both (mixed methods, literature review, or editorial.`) %>%  
  mutate(type_of_analysis = case_when(
    type_of_analysis == "N/A" ~ as.character(NA),
    TRUE ~ type_of_analysis)) 

# check--summarizes counts of each type of analysis (make sure it sums up to the number of papers in the analytical dataset):
table(content_recode$type_of_analysis)

################################################################################

# create a new variable that recodes the dichotomous/check-all column options into a single categorical variable (i.e., UP_urban_rural).
# then create additional dichotomous variables (i.e., target_pop_urban, target_pop_rural), based on the created urban_rural variable so that "Both" counts as "target_pop_urban" and as "target_pop_rural":
content_recode <- content_recode %>% 
  rename(Rurala = Rural...21) %>%
  mutate(UP_urban_rural = case_when( 
                                  (Rurala == 1 & Urban==1) ~ "Both",
                                  (Rurala == 0 & Urban==1) ~ "Urban",
                                  (Rurala == 1 & Urban==0) ~ "Rural",
                                  (Rurala == 0 & Urban==0) ~ as.character(NA)),
         target_pop_urban = case_when(
           UP_urban_rural %in% c("Both","Urban") ~ 1,
           TRUE ~ 0),
         target_pop_rural = case_when(
           UP_urban_rural%in% c("Both","Rural") ~ 1,
           TRUE ~ 0))

# check--summarizes cross-tab counts of new categorical variable to previous dichotomous variables:
table(content_recode$UP_urban_rural, 
      content_recode$Urban, content_recode$Rurala)

table(content_recode$Urban, 
      content_recode$target_pop_urban)

table(content_recode$Rurala,
      content_recode$target_pop_rural)

################################################################################

# create a new variable that recodes the dichotomous/check-all column options into a single categorical variable (i.e., UP_age):
content_recode <- content_recode %>%
  mutate(UP_age = case_when(
         `Children and adolescents (< 18 yo)` == 1 ~ "UP_children",
         `Older Adults`  == 1 ~ "UP_elders",
          TRUE ~ "not_UP_age")) %>%
# rename the dichotomous/check-all columns:
  rename(target_pop_children = `Children and adolescents (< 18 yo)`, 
         target_pop_elders = `Older Adults` )

# check--summarizes cross-tab counts of new categorical variable to previous dichotomous variables:
table(content_recode$UP_age,
      content_recode$target_pop_children)

table(content_recode$UP_age,
      content_recode$target_pop_elders)

################################################################################

# create a new variable that recodes the dichotomous/check-all column options into a single categorical variable (i.e., UP_SES): 
content_recode <- content_recode %>%
  mutate(UP_SES = case_when(
    `Low socioeconomic status` == 1 ~ "UP_low_SES",
    `Low socioeconomic status` == 0 ~ "not_UP_SES")) %>%
# rename the dichotomous/check-all columns:
  rename(target_pop_SES = `Low socioeconomic status`)

# check--summarizes cross-tab counts of new categorical variable to previous dichotomous variables:
table(content_recode$UP_SES,
      content_recode$target_pop_SES)

################################################################################

# create a new variable that recodes the dichotomous/check-all column options into a single categorical variable (i.e., UP_HCW):
content_recode <- content_recode %>%
  mutate(UP_HCW = case_when(
    `Health care worker` == 1 ~ "UP_healthcare_worker",
    `Health care worker` == 0 ~ "not_UP_healthcare_worker")) %>%
# rename the dichotomous/check-all columns:
  rename(target_pop_HCW = `Health care worker`)

# check--summarizes cross-tab counts of new categorical variable to previous dichotomous variables:
table(content_recode$UP_HCW,
      content_recode$target_pop_HCW)

################################################################################

# create a new variable that recodes the dichotomous/check-all column options into a single categorical variable (i.e., UP_teacher):
content_recode <- content_recode %>%
  mutate(UP_teacher = case_when(
    Teacher == 1 ~ "UP_teacher",
    Teacher == 0 ~ "not_UP_teacher")) %>%
# rename the dichotomous/check-all columns:
  rename(target_pop_teacher = Teacher)

# check--summarizes cross-tab counts of new categorical variable to previous dichotomous variables:
table(content_recode$UP_teacher, 
      content_recode$target_pop_teacher)

################################################################################

# create a new variable that recodes the dichotomous/check-all column options into a single categorical variable (i.e., UP_race):
content_recode <- content_recode %>%
  mutate(UP_race = case_when( 
    (`Asian American` == 1 |
     `Native Hawaiian` == 1 |
     `Pacific Islander` == 1) & 
     `Black or African American` == 0 & 
     `Hispanic or Latino`== 0 ~ "UP_Asian",
    
    (`American Indian` == 1 |
     `Alaska Native` == 1) & 
     `Black or African American` == 0 & 
     `Hispanic or Latino`== 0 ~ "UP_Indigenous",
    
     `Black or African American` == 1 & 
     `Hispanic or Latino` == 0 ~ "UP_Black",
    
     `Black or African American` == 0 & 
     `Hispanic or Latino` == 1 ~ "UP_Latinx",
    
     `Black or African American` == 1 & 
     `Hispanic or Latino` == 1 & 
     `American Indian` == 0 & 
     `Asian American` == 0 ~ "UP_Black Latinx",
    
     `Black or African American` == 1 & 
     `Hispanic or Latino` == 1 & 
     `American Indian` == 1 & 
     `Asian American` == 0 ~ "UP_Black Indigenous Latinx",
    
     `Black or African American` == 1 &
     `Hispanic or Latino` == 1 & 
     `Asian American` == 1 &
     `American Indian` == 0 ~ "UP_Black Latinx Asian",
    
      TRUE ~ "no_race_target"),
         
    target_race_binary = case_when(
      UP_race == "no_race_target" ~ 0,
      TRUE ~ 1)) %>%
  
# rename the dichotomous/check-all columns:
  rename(target_pop_Black = `Black or African American`,
         target_pop_Latinx = `Hispanic or Latino`,
         target_pop_Indigenous = `American Indian`,
         target_pop_Asian = `Asian American`)

# check--summarizes cross-tab counts of new categorical variable to previous dichotomous variables:
table(content_recode$UP_race,
      content_recode$target_pop_Black)

table(content_recode$UP_race,
      content_recode$target_pop_Latinx)

table(content_recode$UP_race, 
      content_recode$target_pop_Indigenous)

table(content_recode$UP_race, 
      content_recode$target_pop_Asian)

table(content_recode$UP_race, 
      content_recode$target_race_binary)

################################################################################

# create a new dataframe (i.e., site_recode) that keeps and renames dichotomous/check-all variables:
site_recode <- content_recode %>%
  select(community_health_center = `Community health center`,
         hospital = `Hospital` ,
         in_home = `In-home` ,
         prison = `Prison/jail` ,
         care_facility = `Residential care facility`,
         school = `School` ,
         other = `Other Setting 1`) %>%
  mutate(hospital = case_when(
           other == "university-based hospital system" ~ 1,
           TRUE ~ hospital),
    
         community_events = case_when(
           other %in% c("Community organization",
                        "Free community-based Latino testing events",
                        "Street outreach") ~ 1 ,
           TRUE ~ 0),
         
         vaccination_sites = case_when(
           other %in% c("Vaccination sites: churches, clinics, and community events were the COVID-19 vaccine was being administered",
                        "Vaccination sites [outpatient primary care clinics, churches, community events, and outdoor vaccination drive through locations]") ~ 1 ,
           TRUE~0),
         
         other = case_when(
           is.na(other) | 
           hospital == 1 | 
           community_events == 1|
           vaccination_sites == 1 ~ 0,
           !is.na(other) ~ 1))

#writing a little function to help in recoding below
which_site <- function(x, y){names(which(x==y))[1]}

#here we locate which column (community health center, school, etc.)
#there is a 1 and then grabbing the columns name for that column and 
#putting in variable called study_site_recode. also dealing with missing
#values, if "missing" make it an NA. 

site_recode <- site_recode  %>%
  mutate(study_site_recode = apply(site_recode, 1, which_site, y = 1))

# note that a few publications had multiple sites
# "community_health_center" "other": coded as community_health_center
#"hospital"      "care_facility": coded as hospital

# putting recoded version of study site back onto data frame of interest

content_recode <- content_recode %>% 
  mutate(study_site_recode = site_recode$study_site_recode)

#quick check:
table(content_recode$study_site_recode, 
      content_recode$`School`)

table(content_recode$study_site_recode, 
      content_recode$`Community health center`)

################################################################################

#Study Design
 
#renaming variable names to clean things up:
design_recode <- content_recode %>%
  select(experimental = `Experimental`,
         quasi_experimental = `Quasi-Experimental` ,
         simulation = `Simulation` ,
         observational = `Observational` ,
         evaluation = `Evaluation` ,
         formative = `Formative/exploratory`,
         dissemination = `Dissemination & implementation`,
         cost_benefit = `Cost-benefit` ,
         quant_other = `Other Quantitative Method`,
         focus_group = `Focus group` ,
         interview = `Interview`,
         survey = `Survey`,
         qual_other = `Other Qualitative`)

#writing a little function to help in recoding below
#take each study design, note if used it and paste it with other
#study design types, as studies can have multiple study designs.

which_design <-function(x, y){paste(names(which(x==y)), collapse = ".")}

design_recode <- design_recode  %>%
  mutate(study_design_recode = apply(design_recode , 1, which_design, y = 1) ,
         study_design_recode = case_when(
           study_design_recode == "" ~ "no_study_design",
           TRUE ~ study_design_recode))

#put study design recoded variables onto the content_recode data frame
content_recode <- bind_cols(content_recode, design_recode,
                            .name_repair = "minimal")

#quick check:
table(design_recode$study_design_recode, 
      design_recode$observational)

################################################################################

#single variable, combining detailed study design with type of analysis?

#study_design %>% 
#  mutate(type_of_analysis_detailed = case_when(
#    TRUE ~ content_recode$type_of_analysis)
#         )

################################################################################

# Community Engagement
# now recoding community engagement, one variable if any community engagement
# and then type of community engagement, detailed 
# renaming variables and making other binary 0/1

community_engage <- content_recode %>%
  select(engage_broadcast_media = `Broadcast media (e.g., press conferences, TV interviews`,
         engage_entertainment = `Entertainment activities (e.g., picnics, raffles` ,
         engage_focus_groups = `Focus groups and/or surveys` ,
         engage_meetings_events = `In-person or online community presentations or meetings (professional or educational events` ,
         engage_social_media = `Internet/social media (e.g., email blast, blog, Facebook, YouTube`,
         engage_partnerships = `Partnerships with community-based organizations` ,
         engage_print_media = `Print media (e.g., press releases, newspaper articles`,
         engage_other1 = `Other Community Engagement 1`,
         engage_other2 = `Other Community Engagement 2`) %>%
  mutate(engage_advisory_board = case_when(engage_other1  %in% 
                              c("ad-hoc advisory group of community leaders in each SYCT county todevelop a community-informed strategy for distribution of at-home test kits",
                                "Community Advisory Boards") ~ 1, 
                              TRUE ~ 0),
    
    engage_peer_influence= case_when(engage_other1  %in% 
                              c("Identifying frontline champions",
                                "Peer influencers",
                                "Community member referral networks") ~ 1, 
                              TRUE ~ 0),
    engage_transportation= case_when(engage_other1  %in% 
                              c("Street outreach; mobile vans",
                                "transportation to vaccination sites;  a network of public health/clinical health service providers to provide vaccinations; widespread vaccinations sites (ex. malls; removal of residential status as a barrier to obtain vaccines; public health worker delivery of vaccines in rural areas") ~ 1, 
                              TRUE ~ 0),
    
    engage_partnerships = case_when(engage_other1  %in% 
                              c("COVID-19 data collection through the partnership for decision-making",
                                "Multi-disciplinary  collaborative  research and partnerships  focused  on  addressing community needs and building a translational science workforce to enhance project implementation and reach; faculty  members  engage  closely  with  local  health  departments,",
                                "Conducted an Asian-American and Native Hawaiian/Pacific Islander COVID-19 Needs Assessment") ~ 1,
                              TRUE ~ engage_partnerships),
    engage_meetings_events = case_when(engage_other1 %in% 
                              c("Free community-based Latino testing events") ~ 1,
                              TRUE ~ engage_meetings_events),
    engage_other1 = case_when(is.na(engage_other1) | 
                                engage_advisory_board == 1 |
                                engage_peer_influence == 1 |
                                engage_partnerships == 1 |
                                engage_meetings_events == 1 |
                                engage_transportation == 1 ~ 0,
                                !is.na(engage_other1) ~ 1),
    engage_other2 = case_when(is.na(engage_other2) ~ 0,
                             !is.na(engage_other2) ~ 1))
 
community_engage  <- community_engage   %>%
  mutate(community_engage_number = apply(community_engage[, ], 1, sum),
         community_engage_binary = 1 * (community_engage_number > 0),
         community_engage_recode = apply(community_engage  , 1, which_design, y = 1) ,
         community_engage_recode = case_when(community_engage_recode == "" ~ "no_engagement",
                                         TRUE ~ community_engage_recode))

print(community_engage, width=100000, n =15)

table(community_engage$community_engage_recode)

table(community_engage$community_engage_recode, 
      community_engage$community_engage_binary)

#put study design recoded variables onto the content_recode data frame:
content_recode <- bind_cols(content_recode, community_engage,
                            .name_repair = "minimal")

################################################################################

# TSBM (translational science benefits model)  vaccines

# need to create 4 basic variables of 1 = did translational science model
# and 0 = did not do it
# then create variable of combinations, number of TSMB as well as binary indicator

# here for vaccines

# here we recode the main variables for clinical, public health, economic
# and policy. recode so that a 1 is did that benefit and 0 otherwise 

content_recode <- content_recode %>%
  mutate(
    TSBM_vaccines_clinical = case_when(
      (`Vaccination Clinical Guidelines` == 1 |
       `Vaccination Procedures` == 1 |
       `Vaccine Technology`== 1) ~ 1,
        TRUE ~ 0),
    TSBM_vaccines_public_health = case_when(
      (`Community Vaccination Services` == 1 |
       `Vaccine Education Resources` == 1 |
       `Vaccination Accessibility`== 1|
       `Vaccine Delivery and Uptake`== 1|
       `Vaccine Hesitancy`== 1|
       `Software and Digital Health for Vaccination`==1|
       `Public Health Vaccination Practices`==1) ~ 1,
        TRUE ~ 0),
   TSBM_vaccines_economic = case_when(
     (`Vaccine License Agreements and Patents` == 1 |
      `Vaccine Non-Profit or Commercial Entities` == 1 |
      `Vaccine Cost Effectiveness`== 1|
      `Vaccine Cost Savings`== 1) ~ 1,
      TRUE ~ 0),
  TSBM_vaccines_policy = case_when(
    (`Vaccination Advisory Activities` == 1 |
     `Vaccination Policies and Legislation` == 1) ~ 1,
      TRUE ~ 0))

#now creating extra variables, number of TSBM benefits, pasted together
#benefits they did and binary indicator if did any benefit

TSBM_vaccine_columns <- c("TSBM_vaccines_clinical", 
                          "TSBM_vaccines_public_health",
                          "TSBM_vaccines_economic", 
                          "TSBM_vaccines_policy")

content_recode <- content_recode   %>%
  mutate(TSBM_vaccines_number = apply(content_recode[, TSBM_vaccine_columns], 1, sum),
         TSBM_vaccines_binary = 1 * (TSBM_vaccines_number > 0),
         TSBM_vaccines_recode = apply(content_recode[, TSBM_vaccine_columns], 1, which_design, y = 1) ,
         TSBM_vaccines_recode = case_when(TSBM_vaccines_recode == "" ~ "no_TSBM_vaccines",
                                             TRUE ~ TSBM_vaccines_recode))

#quick check:
print(content_recode[,c(TSBM_vaccine_columns, 
                        "TSBM_vaccines_binary", 
                        "TSBM_vaccines_recode", 
                        "TSBM_vaccines_number")],
      width=1000)


table(content_recode$TSBM_vaccines_binary, 
      content_recode$TSBM_vaccines_number)

table(content_recode$TSBM_vaccines_binary, 
      content_recode$TSBM_vaccines_recode)

################################################################################

# TSBM (translational science benefits model) testing

content_recode <- content_recode %>%
  mutate(
    TSBM_testing_clinical = case_when(
      (`Testing Clinical Guidelines` == 1 |
       `Testing Procedures` == 1 |
       `Testing Technology`== 1) ~ 1,
        TRUE ~ 0),
    TSBM_testing_public_health = case_when(
      (`Community Testing Services` == 1 |
       `Testing Education Resources` == 1 |
       `Testing Accessibility`== 1|
       `Testing Hesitancy`== 1|
       `Software and Digital Health for Testing`== 1|
       `Public Health Testing Practices`== 1) ~ 1,
        TRUE ~ 0),
    TSBM_testing_economic = case_when(
      (`Testing License Agreements and Patents` == 1 |
       `Testing Non-Profit or Commercial Entities` == 1 |
       `Testing Cost Effectiveness`== 1|
       `Testing Cost Savings`== 1) ~ 1 ,
        TRUE ~ 0),
    TSBM_testing_policy = case_when(
      (`Testing Advisory Activities` == 1 |
       `Testing Policies and Legislation` == 1) ~ 1,
        TRUE ~ 0) )

#now creating extra variables, number of TSBM benefits, pasted together
#benefits they did and binary indicator if did any benefit

TSBM_testing_columns <- c("TSBM_testing_clinical", 
                          "TSBM_testing_public_health",
                          "TSBM_testing_economic",
                          "TSBM_testing_policy")

content_recode  <- content_recode   %>%
  mutate(TSBM_testing_number = apply(content_recode[, TSBM_testing_columns], 1, sum),
         TSBM_testing_binary = 1 * (TSBM_testing_number > 0),
         TSBM_testing_recode = apply(content_recode[, TSBM_testing_columns], 1, which_design, y = 1) ,
         TSBM_testing_recode = case_when(TSBM_testing_recode == "" ~ "no_TSBM_vaccines",
                                          TRUE ~ TSBM_testing_recode))

#quick check:
print(content_recode[, c(TSBM_testing_columns, 
                         "TSBM_testing_binary", 
                         "TSBM_testing_recode", 
                         "TSBM_testing_number")],
      width=1000)

table(content_recode$TSBM_testing_binary, 
      content_recode$TSBM_testing_number)

table(content_recode$TSBM_testing_binary, 
      content_recode$TSBM_testing_recode)

#rename some health variables

content_recode <- content_recode %>% 
  rename(Neurological = `Neurological disorders (includes Guillain-Barre syndrome)`,
         HIV = `HIV/AIDS`,
         HepC = `Hepatitis C`,
         Diabetes = `Diabetes, Hyperglycemia or Hypoglycemia`)

#reduce to key variables of interest:

vars <- c("pmid", 
          "UP_urban_rural", 
          "type_of_analysis" ,
          "health_equity_addressed", 
          "UP_age",
          "target_pop_children", 
          "target_pop_elders", 
          "UP_SES", 
          "target_pop_SES",
          "UP_HCW", 
          "target_pop_HCW", 
          "UP_teacher", 
          "target_pop_teacher",
          "target_pop_urban", 
          "target_pop_rural",
          "UP_race", 
          "target_race_binary",
          "target_pop_Black", 
          "target_pop_Latinx", 
          "target_pop_Indigenous", 
          "target_pop_Asian",
          "study_site_recode", 
          colnames(design_recode),
          colnames(community_engage), 
          TSBM_vaccine_columns, 
          "TSBM_vaccines_binary", 
          "TSBM_vaccines_recode", 
          "TSBM_vaccines_number",
          TSBM_testing_columns, 
          "TSBM_testing_binary", 
          "TSBM_testing_recode", 
          "TSBM_testing_number",
          "Neurological",  
          "HIV", 
          "HepC", 
          "Diabetes", 
          "Obesity", 
          "Preeclampsia")

 content_recode <- content_recode %>% select(all_of(vars))

################################################################################

# read in (or import) recoded publication *.csv file:
pubs <- read_csv("2021.09.23 Publications_with_date_variables.csv") %>%
# duplicate PMIDs may be associated more than one project, but we only need them once since we're only interested in the attributes of the paper. if the following variables are distinct (i.e., unique PubMed ID numbers), then keep the values (?):
  distinct(pmid, .keep_all = T)

pubs <- pubs %>% 
  # select useful columns to keep in the dataframe:
  select(cycle, year_cite, month, day, 
         date_publish, weeks_from_start, months_from_start, pmid, title)

################################################################################

# merge content analysis data onto publication data and export

publication_attributes <- left_join(x = content_recode, y = pubs, by = "pmid")

#only keep publication if on pub-author edgelist?
temp_edges <- read_csv("2021.09.23 Author_Affiliations_no_missing_ids.csv")

publication_attributes <- publication_attributes  %>%
  filter(pmid %in% temp_edges$pmid)

# output (or export) the publication_attributes dataframe you created to a *.csv file:
write_csv(publication_attributes, "2021.09.23 Publication_Attribute_Data.csv")
```

## 5.

```{r, echo=FALSE}

```

## 6.

```{r}

```

## 7.

```{r}

```

## 8.

```{r}

```

## 9.

```{r}

```

## 10.

```{r}

```

## 11.

```{r}

```